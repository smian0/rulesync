import { join } from "path";
import { ToolFile } from "../types/tool-file.js";
import { ValidationResult } from "../types/ai-file.js";

export interface CursorGenericContentOptions {
  fileName: string;
  fileContent: string;
  contentType: string;
  relativePath: string;
}

/**
 * Cursor-specific generic content file
 * Converts any Claude Code content type to Cursor .mdc format
 */
export class CursorGenericContent extends ToolFile {
  private readonly contentType: string;
  private readonly sourceRelativePath: string;

  constructor({ fileName, fileContent, contentType, relativePath }: CursorGenericContentOptions) {
    const baseName = fileName.replace(/\.[^/.]+$/, ""); // Remove extension
    const cursorFileName = `${contentType}-${baseName}.mdc`;

    super({
      baseDir: ".",
      relativeDirPath: ".cursor/rules",
      relativeFilePath: cursorFileName,
      fileContent: fileContent,
      validate: false // Disable parent validation, we'll validate after setting our properties
    });
    
    this.contentType = contentType;
    this.sourceRelativePath = relativePath;
    
    // Now validate with all properties set
    const result = this.validate();
    if (!result.success) {
      throw result.error;
    }
  }

  validate(): ValidationResult {
    // Basic validation - ensure we have content and proper content type
    if (!this.contentType || !super.getFileContent()) {
      return {
        success: false,
        error: new Error(`Invalid generic content: missing content type or file content`)
      };
    }
    
    return { success: true, error: null };
  }

  getFileContent(): string {
    // Format content for Cursor with metadata header
    const header = this.createContentHeader();
    const processedContent = this.processContent(super.getFileContent());
    
    return `${header}\n\n${processedContent}`;
  }

  getRelativePath(): string {
    return this.sourceRelativePath;
  }

  private createContentHeader(): string {
    return `<!-- Generated from .claude/${this.contentType}/${this.sourceRelativePath} -->\n` +
           `<!-- Content Type: ${this.contentType} -->\n` +
           `<!-- Generated by rulesync Universal Claude Code Sync -->`;
  }

  private processContent(content: string): string {
    // Process content for Cursor compatibility
    let processedContent = content;
    
    // Convert Claude Code specific patterns to generic format
    processedContent = this.convertClaudeCodePatterns(processedContent);
    
    // Ensure proper formatting for Cursor
    processedContent = this.ensureCursorCompatibility(processedContent);
    
    return processedContent;
  }

  private convertClaudeCodePatterns(content: string): string {
    // Convert Claude Code specific syntax to generic format
    let converted = content;
    
    // Convert file references to generic format
    converted = converted.replace(
      /`\.claude\/([^`]+)`/g, 
      '`.claude/$1` (Claude Code specific)'
    );
    
    // Convert command references to generic format  
    converted = converted.replace(
      /\/([a-z-]+:[a-z-]+)/g,
      '`$1` (Claude Code command)'
    );
    
    return converted;
  }

  private ensureCursorCompatibility(content: string): string {
    // Ensure content is properly formatted for Cursor
    let compatible = content;
    
    // Ensure proper line endings
    compatible = compatible.replace(/\r\n/g, '\n');
    
    // Ensure content ends with newline
    if (!compatible.endsWith('\n')) {
      compatible += '\n';
    }
    
    return compatible;
  }
}