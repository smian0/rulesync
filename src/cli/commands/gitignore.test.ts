import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { gitignoreCommand } from "./gitignore.js";

vi.mock("node:fs");

const mockExistsSync = vi.mocked(existsSync);
const mockReadFileSync = vi.mocked(readFileSync);
const mockWriteFileSync = vi.mocked(writeFileSync);

describe("gitignoreCommand", () => {
  beforeEach(() => {
    vi.clearAllMocks();
    vi.spyOn(console, "log").mockImplementation(() => {});
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("should create .gitignore with rules when file does not exist", async () => {
    mockExistsSync.mockReturnValue(false);

    await gitignoreCommand();

    expect(mockWriteFileSync).toHaveBeenCalledWith(
      expect.stringContaining(".gitignore"),
      expect.stringContaining("# Generated by rulesync"),
    );
    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining("✅ Added 29 rules to .gitignore:"),
    );
  });

  it("should append rules to existing .gitignore", async () => {
    const existingContent = "node_modules/\n*.log\n";

    mockExistsSync.mockReturnValue(true);
    mockReadFileSync.mockReturnValue(existingContent);

    await gitignoreCommand();

    expect(mockWriteFileSync).toHaveBeenCalledWith(
      expect.stringContaining(".gitignore"),
      expect.stringContaining(existingContent),
    );
    expect(mockWriteFileSync).toHaveBeenCalledWith(
      expect.stringContaining(".gitignore"),
      expect.stringContaining(".github/instructions/"),
    );
  });

  it("should not add duplicate rules", async () => {
    const existingContent = `node_modules/
# Generated by rulesync - AI tool configuration files
.github/copilot-instructions.md
.github/instructions/
.cursor/rules/
.cursorignore
.clinerules/
.clineignore
CLAUDE.md
.claude/memories/
.roo/rules/
.rooignore
.copilotignore
GEMINI.md
.gemini/memories/
.aiexclude
.aiignore
.kiro/steering/
.augment/rules/
.augment-guidelines
.mcp.json
!.rulesync/.mcp.json
.cursor/mcp.json
.cline/mcp.json
.vscode/mcp.json
.gemini/settings.json
.roo/mcp.json
# Support for --base-dir option (any depth)
**/.github/copilot-instructions.md
**/.github/instructions/
**/.cursor/rules/
**/.cursorignore
**/.clinerules/
**/.clineignore
**/CLAUDE.md
**/.claude/memories/
**/.roo/rules/
**/.rooignore
**/.copilotignore
**/GEMINI.md
**/.gemini/memories/
**/.aiexclude
**/.aiignore
**/.augmentignore
**/.kiro/steering/
**/.augment/rules/
**/.augment-guidelines
**/.junie/guidelines.md
**/.noai
**/.mcp.json
!.rulesync/.mcp.json
**/.cursor/mcp.json
**/.cline/mcp.json
**/.vscode/mcp.json
**/.gemini/settings.json
**/.roo/mcp.json
`;

    mockExistsSync.mockReturnValue(true);
    mockReadFileSync.mockReturnValue(existingContent);

    await gitignoreCommand();

    expect(mockWriteFileSync).not.toHaveBeenCalled();
    expect(console.log).toHaveBeenCalledWith("✅ .gitignore is already up to date");
  });

  it("should add only missing rules to existing .gitignore", async () => {
    const existingContent = `node_modules/
**/.github/instructions/
`;

    mockExistsSync.mockReturnValue(true);
    mockReadFileSync.mockReturnValue(existingContent);

    await gitignoreCommand();

    expect(mockWriteFileSync).toHaveBeenCalledWith(
      expect.stringContaining(".gitignore"),
      expect.stringContaining(".cursor/rules/"),
    );
    expect(mockWriteFileSync).toHaveBeenCalledWith(
      expect.stringContaining(".gitignore"),
      expect.stringContaining(".clinerules/"),
    );
    expect(console.log).toHaveBeenCalledWith(
      expect.stringContaining("✅ Added 28 rules to .gitignore:"),
    );
  });
});
